digraph CFG {
  node [shape=box];
  B0 [label="B0: 3: #include <stdio.h>\n5: #define N 10\n6: typedef struct { int r, c; } Node;\n8: typedef struct {\n9: Node q[N*N];\n10: int head, tail;\n13: void q_init(Queue *Q){ Q->head = 0; Q->tail = 0; }\n14: int q_empty(Queue *Q){ return Q->head == Q->tail; }\n15: void q_push(Queue *Q, Node v){ Q->q[Q->tail++] = v; }\n16: Node q_pop(Queue *Q){ return Q->q[Q->head++]; }\n18: int in_bounds(int r, int c){ return r>=0 && r<N && c>=0 && c<N; }\n20: int main(void) {\n21: int grid[N][N];\n22: int i, j;\n23: printf(\"Enter 10x10 grid (0=free,1=wall):\n\");"];
  B1 [label="B1: 24: for (i = 0; i < N; i++) {"];
  B2 [label="B2: BASIC"];
  B3 [label="B3: 25: for (j = 0; j < N; j++) {"];
  B4 [label="B4: BASIC"];
  B5 [label="B5: 26: if (scanf(\"%d\", &grid[i][j]) != 1) {"];
  B6 [label="B6: 27: printf(\"Bad input\n\");\n28: return 0;"];
  B7 [label="B7: EXIT"];
  B8 [label="B8: BASIC"];
  B9 [label="B9: 30: if (grid[i][j] != 0 && grid[i][j] != 1) {"];
  B10 [label="B10: 31: grid[i][j] = 1;"];
  B11 [label="B11: BASIC"];
  B12 [label="B12: BASIC"];
  B13 [label="B13: 36: int sr, sc, tr, tc;\n37: printf(\"Enter start r c (0-9 0-9): \");"];
  B14 [label="B14: 38: if (scanf(\"%d %d\", &sr, &sc) != 2) return 0;\n39: printf(\"Enter target r c (0-9 0-9): \");"];
  B15 [label="B15: 40: if (scanf(\"%d %d\", &tr, &tc) != 2) return 0;"];
  B16 [label="B16: 42: if (!in_bounds(sr, sc) || !in_bounds(tr, tc)) {"];
  B17 [label="B17: 43: printf(\"Out of bounds\n\");\n44: return 0;"];
  B18 [label="B18: BASIC"];
  B19 [label="B19: 46: if (grid[sr][sc] == 1 || grid[tr][tc] == 1) {"];
  B20 [label="B20: 47: printf(\"Start/target blocked\n\");\n48: return 0;"];
  B21 [label="B21: 51: int dist[N][N];\n52: int vis[N][N];"];
  B22 [label="B22: 53: for (i = 0; i < N; i++) {"];
  B23 [label="B23: BASIC"];
  B24 [label="B24: 54: for (j = 0; j < N; j++) {"];
  B25 [label="B25: 55: dist[i][j] = -1;\n56: vis[i][j] = 0;"];
  B26 [label="B26: BASIC"];
  B27 [label="B27: 60: Queue Q; q_init(&Q);\n61: q_push(&Q, (Node){sr, sc});\n62: vis[sr][sc] = 1;\n63: dist[sr][sc] = 0;\n65: int dr[4] = {-1, 1, 0, 0};\n66: int dc[4] = {0, 0, -1, 1};"];
  B28 [label="B28: 68: while (!q_empty(&Q)) {"];
  B29 [label="B29: 69: Node u = q_pop(&Q);"];
  B30 [label="B30: 70: if (u.r == tr && u.c == tc) break;"];
  B31 [label="B31: 71: for (int k = 0; k < 4; k++) {"];
  B32 [label="B32: 72: int nr = u.r + dr[k];\n73: int nc = u.c + dc[k];"];
  B33 [label="B33: 74: if (in_bounds(nr, nc)) {"];
  B34 [label="B34: BASIC"];
  B35 [label="B35: 75: if (!vis[nr][nc] && grid[nr][nc] == 0) {"];
  B36 [label="B36: 76: vis[nr][nc] = 1;\n77: dist[nr][nc] = dist[u.r][u.c] + 1;\n78: q_push(&Q, (Node){nr, nc});"];
  B37 [label="B37: BASIC"];
  B38 [label="B38: BASIC"];
  B39 [label="B39: BASIC"];
  B40 [label="B40: BASIC"];
  B41 [label="B41: 84: if (dist[tr][tc] == -1) {"];
  B42 [label="B42: 85: printf(\"No path\n\");\n86: } else {\n87: printf(\"Shortest path length: %d\n\", dist[tr][tc]);\n89: int r = tr, c = tc;\n90: int steps = dist[tr][tc];"];
  B43 [label="B43: 91: while (steps > 0) {"];
  B44 [label="B44: 92: int found = 0;"];
  B45 [label="B45: 93: for (int k = 0; k < 4; k++) {"];
  B46 [label="B46: 94: int pr = r - dr[k];\n95: int pc = c - dc[k];"];
  B47 [label="B47: 96: if (in_bounds(pr, pc) && dist[pr][pc] == steps - 1) {"];
  B48 [label="B48: 97: r = pr; c = pc; steps = steps - 1;\n98: found = 1;\n99: break;"];
  B49 [label="B49: BASIC"];
  B50 [label="B50: BASIC"];
  B51 [label="B51: 102: if (!found) break;"];
  B52 [label="B52: BASIC"];
  B53 [label="B53: 104: if (r == sr && c == sc && steps == 0) {"];
  B54 [label="B54: 105: printf(\"Path check OK\n\");\n106: } else {\n107: printf(\"Path reconstruction incomplete (but length is valid)\n\");"];
  B55 [label="B55: BASIC"];
  B56 [label="B56: 110: return 0;"];
  B57 [label="B57: BASIC"];
  B0 -> B1;
  B1 -> B2 [label="body"];
  B2 -> B3;
  B3 -> B4 [label="body"];
  B4 -> B5;
  B5 -> B6 [label="true"];
  B6 -> B7 [label="return"];
  B7 -> B8;
  B5 -> B8 [label="false"];
  B8 -> B9;
  B9 -> B10 [label="true"];
  B10 -> B11;
  B9 -> B11 [label="false"];
  B11 -> B3 [label="back"];
  B3 -> B12 [label="false"];
  B12 -> B1 [label="back"];
  B1 -> B13 [label="false"];
  B13 -> B14;
  B14 -> B15;
  B15 -> B16;
  B16 -> B17 [label="true"];
  B17 -> B7 [label="return"];
  B7 -> B18;
  B16 -> B18 [label="false"];
  B18 -> B19;
  B19 -> B20 [label="true"];
  B20 -> B7 [label="return"];
  B7 -> B21;
  B19 -> B21 [label="false"];
  B21 -> B22;
  B22 -> B23 [label="body"];
  B23 -> B24;
  B24 -> B25 [label="body"];
  B25 -> B24 [label="back"];
  B24 -> B26 [label="false"];
  B26 -> B22 [label="back"];
  B22 -> B27 [label="false"];
  B27 -> B28;
  B28 -> B29 [label="body"];
  B29 -> B30;
  B30 -> B31;
  B31 -> B32 [label="body"];
  B32 -> B33;
  B33 -> B34 [label="true"];
  B34 -> B35;
  B35 -> B36 [label="true"];
  B36 -> B37;
  B35 -> B37 [label="false"];
  B37 -> B38;
  B33 -> B38 [label="false"];
  B38 -> B31 [label="back"];
  B31 -> B39 [label="false"];
  B39 -> B40;
  B30 -> B40 [label="false"];
  B40 -> B41;
  B41 -> B42 [label="true"];
  B42 -> B43;
  B43 -> B44 [label="body"];
  B44 -> B45;
  B45 -> B46 [label="body"];
  B46 -> B47;
  B47 -> B48 [label="true"];
  B48 -> B49;
  B47 -> B49 [label="false"];
  B49 -> B45 [label="back"];
  B45 -> B50 [label="false"];
  B50 -> B51;
  B51 -> B52;
  B51 -> B52 [label="false"];
  B52 -> B53;
  B53 -> B54 [label="true"];
  B54 -> B55;
  B53 -> B55 [label="false"];
  B55 -> B43 [label="back"];
  B43 -> B56 [label="false"];
  B56 -> B7 [label="return"];
  B7 -> B57;
  B41 -> B57 [label="false"];
  B57 -> B7;
}