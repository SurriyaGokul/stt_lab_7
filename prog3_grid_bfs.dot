digraph CFG {
  node [shape=box];
  B0 [label="B0: 3: #include <stdio.h>\n5: #define N 10\n6: typedef struct { int r, c; } Node;\n8: typedef struct {\n9: Node q[N*N];\n10: int head, tail;\n13: void q_init(Queue *Q){ Q->head = 0; Q->tail = 0; }\n14: int q_empty(Queue *Q){ return Q->head == Q->tail; }\n15: void q_push(Queue *Q, Node v){ Q->q[Q->tail++] = v; }\n16: Node q_pop(Queue *Q){ return Q->q[Q->head++]; }\n18: int in_bounds(int r, int c){ return r>=0 && r<N && c>=0 && c<N; }\n20: int main(void) {\n21: int grid[N][N];\n22: int i, j;\n23: printf(\"Enter 10x10 grid (0=free,1=wall):\n\");"];
  B1 [label="B1: 24: for (i = 0; i < N; i++) {"];
  B2 [label="B2: 25: for (j = 0; j < N; j++) {"];
  B3 [label="B3: 26: if (scanf(\"%d\", &grid[i][j]) != 1) {\n27: printf(\"Bad input\n\");\n28: return 0;"];
  B4 [label="B4: EXIT"];
  B5 [label="B5: BASIC"];
  B6 [label="B6: 30: if (grid[i][j] != 0 && grid[i][j] != 1) {\n31: grid[i][j] = 1;"];
  B7 [label="B7: BASIC"];
  B8 [label="B8: BASIC"];
  B9 [label="B9: 36: int sr, sc, tr, tc;\n37: printf(\"Enter start r c (0-9 0-9): \");"];
  B10 [label="B10: 38: if (scanf(\"%d %d\", &sr, &sc) != 2) return 0;\n39: printf(\"Enter target r c (0-9 0-9): \");"];
  B11 [label="B11: 40: if (scanf(\"%d %d\", &tr, &tc) != 2) return 0;"];
  B12 [label="B12: 42: if (!in_bounds(sr, sc) || !in_bounds(tr, tc)) {\n43: printf(\"Out of bounds\n\");\n44: return 0;"];
  B13 [label="B13: BASIC"];
  B14 [label="B14: 46: if (grid[sr][sc] == 1 || grid[tr][tc] == 1) {\n47: printf(\"Start/target blocked\n\");\n48: return 0;"];
  B15 [label="B15: 51: int dist[N][N];\n52: int vis[N][N];"];
  B16 [label="B16: 53: for (i = 0; i < N; i++) {"];
  B17 [label="B17: 54: for (j = 0; j < N; j++) {\n55: dist[i][j] = -1;\n56: vis[i][j] = 0;"];
  B18 [label="B18: BASIC"];
  B19 [label="B19: 60: Queue Q; q_init(&Q);\n61: q_push(&Q, (Node){sr, sc});\n62: vis[sr][sc] = 1;\n63: dist[sr][sc] = 0;\n65: int dr[4] = {-1, 1, 0, 0};\n66: int dc[4] = {0, 0, -1, 1};"];
  B20 [label="B20: 68: while (!q_empty(&Q)) {\n69: Node u = q_pop(&Q);"];
  B21 [label="B21: 70: if (u.r == tr && u.c == tc) break;"];
  B22 [label="B22: 71: for (int k = 0; k < 4; k++) {\n72: int nr = u.r + dr[k];\n73: int nc = u.c + dc[k];"];
  B23 [label="B23: 74: if (in_bounds(nr, nc)) {"];
  B24 [label="B24: 75: if (!vis[nr][nc] && grid[nr][nc] == 0) {\n76: vis[nr][nc] = 1;\n77: dist[nr][nc] = dist[u.r][u.c] + 1;\n78: q_push(&Q, (Node){nr, nc});"];
  B25 [label="B25: BASIC"];
  B26 [label="B26: BASIC"];
  B27 [label="B27: BASIC"];
  B28 [label="B28: BASIC"];
  B29 [label="B29: 84: if (dist[tr][tc] == -1) {\n85: printf(\"No path\n\");\n86: } else {\n87: printf(\"Shortest path length: %d\n\", dist[tr][tc]);\n89: int r = tr, c = tc;\n90: int steps = dist[tr][tc];"];
  B30 [label="B30: 91: while (steps > 0) {\n92: int found = 0;"];
  B31 [label="B31: 93: for (int k = 0; k < 4; k++) {\n94: int pr = r - dr[k];\n95: int pc = c - dc[k];"];
  B32 [label="B32: 96: if (in_bounds(pr, pc) && dist[pr][pc] == steps - 1) {\n97: r = pr; c = pc; steps = steps - 1;\n98: found = 1;\n99: break;"];
  B33 [label="B33: BASIC"];
  B34 [label="B34: BASIC"];
  B35 [label="B35: 102: if (!found) break;"];
  B36 [label="B36: BASIC"];
  B37 [label="B37: 104: if (r == sr && c == sc && steps == 0) {\n105: printf(\"Path check OK\n\");\n106: } else {\n107: printf(\"Path reconstruction incomplete (but length is valid)\n\");"];
  B38 [label="B38: BASIC"];
  B39 [label="B39: 110: return 0;"];
  B40 [label="B40: BASIC"];
  B0 -> B1;
  B1 -> B2;
  B2 -> B3;
  B3 -> B4 [label="return"];
  B3 -> B5 [label="fallthrough"];
  B4 -> B5;
  B5 -> B6;
  B6 -> B7 [label="fallthrough"];
  B6 -> B7;
  B7 -> B2 [label="back"];
  B2 -> B8 [label="exit"];
  B8 -> B1 [label="back"];
  B1 -> B9 [label="exit"];
  B9 -> B10;
  B10 -> B11;
  B11 -> B12;
  B12 -> B4 [label="return"];
  B12 -> B13 [label="fallthrough"];
  B4 -> B13;
  B13 -> B14;
  B14 -> B4 [label="return"];
  B14 -> B15 [label="fallthrough"];
  B4 -> B15;
  B15 -> B16;
  B16 -> B17;
  B17 -> B17 [label="back"];
  B17 -> B18 [label="exit"];
  B18 -> B16 [label="back"];
  B16 -> B19 [label="exit"];
  B19 -> B20;
  B20 -> B21;
  B21 -> B22;
  B22 -> B23;
  B23 -> B24;
  B24 -> B25 [label="fallthrough"];
  B24 -> B25;
  B23 -> B26 [label="fallthrough"];
  B25 -> B26;
  B26 -> B22 [label="back"];
  B22 -> B27 [label="exit"];
  B21 -> B28 [label="fallthrough"];
  B27 -> B28;
  B28 -> B29;
  B29 -> B30;
  B30 -> B31;
  B31 -> B32;
  B32 -> B33 [label="fallthrough"];
  B32 -> B33;
  B33 -> B31 [label="back"];
  B31 -> B34 [label="exit"];
  B34 -> B35;
  B35 -> B36 [label="fallthrough"];
  B35 -> B36;
  B36 -> B37;
  B37 -> B38 [label="fallthrough"];
  B37 -> B38;
  B38 -> B30 [label="back"];
  B30 -> B39 [label="exit"];
  B39 -> B4 [label="return"];
  B29 -> B40 [label="fallthrough"];
  B4 -> B40;
  B40 -> B4 [label="fallthrough"];
}